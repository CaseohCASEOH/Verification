<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Mountain</title>
    <style>
        /* Full-screen background for the 3D model view */
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            background-color: #222222;
        }

        #container {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100%;
            width: 100%;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <!-- Canvas element for Three.js 3D rendering -->
    <div id="container">
        <canvas id="webgl-canvas"></canvas>
    </div>

    <!-- Three.js library, including GLTFLoader for model import -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/loaders/GLTFLoader.min.js"></script>

    <script>
        // Initialize Scene, Camera, and Renderer
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

        const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('webgl-canvas') });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Load the 3D Model with mountain texture (use your specific model path here)
        const loader = new THREE.GLTFLoader();
        loader.load('mountain.glb', function(gltf) {
            const model = gltf.scene;
            scene.add(model);

            model.scale.set(1, 1, 1); // Adjust scale as needed
            model.position.set(0, 0, 0);

            // Add Ambient Lighting to the Scene
            const light = new THREE.AmbientLight(0x404040, 1); // Soft white light
            scene.add(light);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(1, 1, 1).normalize();
            scene.add(directionalLight);
            
        }, undefined, function (error) {
            console.error(error);
        });

        // Camera positioning
        camera.position.z = 5;

        // Mouse drag controls for rotating the model
        let isMouseDown = false;
        let previousMousePosition = { x: 0, y: 0 };

        window.addEventListener('mousedown', (e) => {
            isMouseDown = true;
            previousMousePosition = { x: e.clientX, y: e.clientY };
        });

        window.addEventListener('mouseup', () => {
            isMouseDown = false;
        });

        window.addEventListener('mousemove', (e) => {
            if (!isMouseDown) return;

            const deltaMove = {
                x: e.clientX - previousMousePosition.x,
                y: e.clientY - previousMousePosition.y
            };

            scene.rotation.y += deltaMove.x * 0.01; // Rotate scene horizontally
            scene.rotation.x += deltaMove.y * 0.01; // Rotate scene vertically
            
            previousMousePosition = { x: e.clientX, y: e.clientY };
        });

        // Handle resizing the canvas when window is resized
        window.addEventListener('resize', () => {
            renderer.setSize(window.innerWidth, window.innerHeight);
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
        });

        // Animation loop to render the scene and update the rotation
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>
